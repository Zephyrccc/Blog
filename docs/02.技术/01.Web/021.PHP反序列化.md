---
author: 
  name: Zephyr
title: PHP反序列化
date: 2022-7-21 13:12:03
permalink: /pages/2e1547494524d1d0
tags: 
  - web
  - PHP
  - unserialize

---

# PHP反序列化

## 什么是序列化与反序列化

PHP的序列化就是将各种类型的数据对象转换成一定的格式存储，其目的是为了将一个对象通过可保存的字节方式存储起来这样就可以将学列化字节存储到数据库或者文本当中，当需要的时候再通过反序列化获取

```php
serialize()     //实现变量的序列化，返回结果为字符串
unserialize()    //实现字符串的反序列化，返回结果为变量
```

### 例子

```php
<?php
class Simple{
    private $private = "null";
    public $public = "null";
    protected $protected = "null";

    public function set_attribute($private,$public,$protected){
        $this->private = $private;
        $this->public = $public;
        $this->protected = $protected;
    }
}
$demo = new Simple();
$demo->set_attribute("private","public","protected");
$serialization = serialize($demo);
echo $serialization;
?>
```

输出结果

```
O:6:"Simple":3:{s:15:"<0x00>Simple<0x00>private";s:7:"private";s:6:"public";s:6:"public";s:12:"<0x00>*<0x00>protected";s:9:"protected";}
```

**对于不同权限的属性序列化中的结果也会不一样**

- public：序列化之后就是最普通的方式，属性名和属性值。
- private：私有权限，表示这个属性是该类所有对象共享的属性，属性名和类的名字在一起。序列化结果：%00类名%属性名
- protected：序列化之后的形式就是%00*%00属性名

**另外从结果中也可以发现只有类的属性被序列化，方法并没有被序列化。**

## 魔术函数

|      函数      |                             描述                             |
| :------------: | :----------------------------------------------------------: |
| __construct()  | 构造函数，当对象创建(new)时会自动调用。但在unserialize()时是不会自动调用的 |
|  __destruct()  | 析构函数，类似于C++。会在到某个对象的所有引用都被删除或者当对象被显式销毁时执行，当对象被销毁时会自动调用。使用 exit()终止运行时也会被自动调用 |
|   __wakeup()   | 调用unserialize()方法时会检查是否存在 `__wakeup()`，如果存在，则会优先调用 `__wakeup()`方法 |
|   __sleep()    |                调用serialize()方法时会被调用                 |
|    __get()     | 获取不可访问（private，protect等修饰）或不存在的属性时会被调用 |
|    __set()     | 修改或写入不可访问（private，protect等修饰）或不存在的属性时会被调用 |
|  __toString()  |             类对象被当作一个字符串使用时会被调用             |
|   __isset()    | 对不可访问（private，protect等修饰）属性使用empty()或isset()方法时会被调用 |
|   __unset()    | 对不可访问（private，protect等修饰）属性使用unset()方法时会被调用 |
|    __call()    |            在对象上下文中调用不可访问的方法时触发            |
| __callStatic() |            在静态上下文中调用不可访问的方法时触发            |
|   __invoke()   |       尝试以调用方法的方式调用一个实例化对象时会被调用       |

## __wakeup失效：CVE-2016-7124

- 影响版本为：PHP 5至5.6.25，PHP 7至 7.0.10
- 漏洞概述: `__wakeup()`魔法函数被绕过,导致执行了一些非预期效果的漏洞
- 漏洞原理: 当对象的属性(变量)数大于实际的个数时,`__wakeup()`魔法函数被绕过
